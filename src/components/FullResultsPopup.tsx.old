import React, { useState, useEffect, useMemo } from "react";
import { Button, HTMLSelect, InputGroup, Checkbox } from "@blueprintjs/core";
import { createChildBlock } from "../utils/roamAPI.js";
import { aiCompletion } from "../ai/responseInsertion.js";
import { invokeSearchAgent } from "../ai/agents/search-agent/ask-your-graph-invoke";

interface Result {
  uid?: string;
  content?: string;
  text?: string;
  pageTitle?: string;
  pageUid?: string;
  isDaily?: boolean;
  modified?: Date | string;
  created?: Date | string;
  count?: number;
  [key: string]: any;
}

// Separate component to handle block/page rendering with hooks
const BlockRenderer: React.FC<{ result: Result; index?: number }> = ({ result }) => {
  const containerRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    if (containerRef.current && result.uid) {
      try {
        (window as any).roamAlphaAPI.ui.components.renderBlock({
          uid: result.uid,
          "zoom-path?": true,
          el: containerRef.current,
        });
      } catch (error) {
        console.warn("Failed to render block:", error);
        if (containerRef.current) {
          containerRef.current.textContent =
            result.content || result.text || "Unable to render block";
        }
      }
    } else if (containerRef.current) {
      containerRef.current.textContent =
        result.content || result.text || JSON.stringify(result);
    }
  }, [result]);

  return <div ref={containerRef} style={{ flex: 1 }} />;
};

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

interface FullResultsPopupProps {
  results: Result[];
  isOpen: boolean;
  title?: string;
  targetUid?: string;
  // Privacy mode props for chat functionality
  privateMode?: boolean;
  permissions?: { contentAccess: boolean };
}

const FullResultsPopup: React.FC<FullResultsPopupProps> = ({
  results,
  isOpen,
  title = "Ask your graph: last request full results",
  targetUid,
  privateMode = false,
  permissions = { contentAccess: false },
}) => {
  const [selectedResults, setSelectedResults] = useState<Set<number>>(
    new Set()
  );
  const [dropdownStates, setDropdownStates] = useState<Record<string, boolean>>(
    {}
  );
  const [isClosing, setIsClosing] = useState(false);
  
  // Enhanced filtering and sorting state
  const [searchFilter, setSearchFilter] = useState("");
  const [pageFilter, setPageFilter] = useState("all");
  const [sortBy, setSortBy] = useState<"relevance" | "date" | "page" | "content">("relevance");
  const [sortOrder, setSortOrder] = useState<"asc" | "desc">("desc");
  const [resultsPerPage, setResultsPerPage] = useState(20);
  const [currentPage, setCurrentPage] = useState(1);
  const [showMetadata, setShowMetadata] = useState(true);
  
  // New view mode for pages vs blocks
  const [viewMode, setViewMode] = useState<"blocks" | "pages" | "mixed">("mixed");
  const [pageDisplayMode, setPageDisplayMode] = useState<"metadata" | "embed">("metadata");
  
  // Chat interface state
  const [showChat, setShowChat] = useState(false);
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [chatInput, setChatInput] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [chatMode, setChatMode] = useState<"simple" | "agent">("simple");

  useEffect(() => {
    if (isOpen) {
      setSelectedResults(new Set());
      setSearchFilter("");
      setPageFilter("all");
      setCurrentPage(1);
      setViewMode("mixed"); // Always show mixed view by default
      
      // Reset chat state
      setShowChat(false);
      setChatMessages([]);
      setChatInput("");
      setIsTyping(false);
    }
  }, [isOpen]);

  // Compute unique pages for filter dropdown and detect result types
  const { uniquePages, hasBlocks, hasPages } = useMemo(() => {
    const pages = new Set<string>();
    let hasBlocks = false;
    let hasPages = false;
    
    console.log("🔍 Analyzing results structure:", results);
    
    results.forEach((result, index) => {
      if (result.pageTitle) {
        pages.add(result.pageTitle);
      }
      
      // Debug each result
      console.log(`Result ${index}:`, {
        uid: result.uid,
        content: result.content ? `"${result.content.substring(0, 50)}..."` : null,
        text: result.text ? `"${result.text.substring(0, 50)}..."` : null,
        pageTitle: result.pageTitle,
        pageUid: result.pageUid,
        hasContent: !!(result.content || result.text),
        isPage: !!(result.pageTitle && result.pageUid && !result.content && !result.text)
      });
      
      // Detect if this is a block result or page result
      // Block: has both uid AND pageUid (block is inside a page)
      // Page: has uid but NO pageUid (page itself doesn't have a parent page)
      const isBlockResult = result.uid && result.pageUid;
      const isPageResult = result.uid && !result.pageUid;
      
      if (isBlockResult) {
        hasBlocks = true;
        console.log(`✅ Found block result at index ${index} (has pageUid: ${result.pageUid})`);
      } else if (isPageResult) {
        hasPages = true;
        console.log(`📄 Found page result at index ${index} (no pageUid)`);
      } else {
        console.log(`❓ Unknown result type at index ${index}:`, result);
      }
    });
    
    console.log("📊 Final detection:", { hasBlocks, hasPages, totalResults: results.length });
    
    return {
      uniquePages: Array.from(pages).sort(),
      hasBlocks,
      hasPages
    };
  }, [results]);

  // Apply filters and sorting
  const filteredAndSortedResults = useMemo(() => {
    let filtered = results.filter(result => {
      // View mode filter - use same logic as detection
      const isBlock = result.uid && result.pageUid;
      const isPage = result.uid && !result.pageUid;
      
      if (viewMode === "blocks" && !isBlock) return false;
      if (viewMode === "pages" && !isPage) return false;
      // "mixed" shows both
      
      // Search filter
      if (searchFilter) {
        const searchLower = searchFilter.toLowerCase();
        const matchesContent = result.content?.toLowerCase().includes(searchLower) ||
                             result.text?.toLowerCase().includes(searchLower);
        const matchesPage = result.pageTitle?.toLowerCase().includes(searchLower);
        if (!matchesContent && !matchesPage) return false;
      }
      
      // Page filter
      if (pageFilter !== "all" && result.pageTitle !== pageFilter) {
        return false;
      }
      
      return true;
    });

    // Sort results
    filtered.sort((a, b) => {
      let comparison = 0;
      
      switch (sortBy) {
        case "date":
          const dateA = new Date(a.modified || a.created || 0);
          const dateB = new Date(b.modified || b.created || 0);
          comparison = dateA.getTime() - dateB.getTime();
          break;
        case "page":
          comparison = (a.pageTitle || "").localeCompare(b.pageTitle || "");
          break;
        case "content":
          // Sort by content length first, then alphabetically
          // This helps group similar-length results together
          const contentA = a.content || a.text || "";
          const contentB = b.content || b.text || "";
          if (contentA.length !== contentB.length) {
            comparison = contentA.length - contentB.length;
          } else {
            comparison = contentA.localeCompare(contentB);
          }
          break;
        case "relevance":
        default:
          // For relevance, maintain original order but can be enhanced with scoring
          const indexA = results.indexOf(a);
          const indexB = results.indexOf(b);
          comparison = indexA - indexB;
          break;
      }
      
      return sortOrder === "desc" ? -comparison : comparison;
    });

    return filtered;
  }, [results, searchFilter, pageFilter, sortBy, sortOrder, viewMode]);

  // Pagination
  const totalPages = Math.ceil(filteredAndSortedResults.length / resultsPerPage);
  const paginatedResults = useMemo(() => {
    const startIndex = (currentPage - 1) * resultsPerPage;
    return filteredAndSortedResults.slice(startIndex, startIndex + resultsPerPage);
  }, [filteredAndSortedResults, currentPage, resultsPerPage]);

  // Update currentPage if it exceeds totalPages
  useEffect(() => {
    if (currentPage > totalPages && totalPages > 0) {
      setCurrentPage(1);
    }
  }, [currentPage, totalPages]);

  const handleClose = () => {
    if (isClosing) return;
    setIsClosing(true);

    // Remove the popup container directly
    setTimeout(() => {
      const container = document.getElementById("full-results-popup-container");
      if (container) {
        document.body.removeChild(container);
      }
    }, 100);
  };

  const handleCheckboxChange = (resultIndex: number) => {
    if (isClosing) return; // Prevent state updates if closing
    const newSelected = new Set(selectedResults);
    // Map paginated index to original results array index
    const originalIndex = results.indexOf(paginatedResults[resultIndex]);
    if (newSelected.has(originalIndex)) {
      newSelected.delete(originalIndex);
    } else {
      newSelected.add(originalIndex);
    }
    setSelectedResults(newSelected);
  };

  const handleSelectAll = () => {
    if (isClosing) return; // Prevent state updates if closing
    const currentPageIndices = paginatedResults.map(result => results.indexOf(result));
    const allCurrentSelected = currentPageIndices.every(idx => selectedResults.has(idx));
    
    const newSelected = new Set(selectedResults);
    if (allCurrentSelected) {
      // Deselect all current page results
      currentPageIndices.forEach(idx => newSelected.delete(idx));
    } else {
      // Select all current page results
      currentPageIndices.forEach(idx => newSelected.add(idx));
    }
    setSelectedResults(newSelected);
  };

  const handleSelectAllResults = () => {
    if (isClosing) return;
    if (selectedResults.size === filteredAndSortedResults.length) {
      setSelectedResults(new Set());
    } else {
      const allFilteredIndices = filteredAndSortedResults.map(result => results.indexOf(result));
      setSelectedResults(new Set(allFilteredIndices));
    }
  };

  const getSelectedResultsList = () => {
    return Array.from(selectedResults).map((index) => results[index]);
  };

  // Chat functionality
  const getSelectedResultsForChat = () => {
    const selected = getSelectedResultsList();
    return selected.length > 0 ? selected : paginatedResults;
  };
  
  const canUseChat = () => {
    return !privateMode || permissions.contentAccess;
  };
  
  const handleChatSubmit = async () => {
    if (!chatInput.trim() || isTyping) return;
    
    const userMessage: ChatMessage = {
      role: 'user',
      content: chatInput.trim(),
      timestamp: new Date()
    };
    
    setChatMessages(prev => [...prev, userMessage]);
    setChatInput("");
    setIsTyping(true);
    
    try {
      const selectedResults = getSelectedResultsForChat();
      await processChatMessage(userMessage.content, selectedResults);
    } catch (error) {
      console.error("Chat error:", error);
      const errorMessage: ChatMessage = {
        role: 'assistant',
        content: "Sorry, I encountered an error processing your request. Please try again.",
        timestamp: new Date()
      };
      setChatMessages(prev => [...prev, errorMessage]);
    }
    
    setIsTyping(false);
  };
  
  const processChatMessage = async (message: string, contextResults: Result[]) => {
    // Prepare context from results
    const context = contextResults.map(result => {
      const content = result.content || result.text || "";
      const pageInfo = result.pageTitle ? `Page: ${result.pageTitle}` : "";
      const uid = result.uid ? `UID: ${result.uid}` : "";
      return `${pageInfo}\n${content}\n${uid}`.trim();
    }).join("\n\n---\n\n");

    let aiResponse: string;

    if (chatMode === "agent" && !privateMode && permissions.contentAccess) {
      // Use full agent with tools for complex analysis
      try {
        console.log("🔍 Using agent mode for complex analysis");
        const agentResult = await invokeSearchAgent({
          model: "gpt-4o-mini", // Or use user's default model
          rootUid: targetUid || "",
          targetUid: targetUid,
          target: "new",
          prompt: `Context: I'm analyzing search results. Here are the results I'm working with:\n\n${context}\n\nUser question: ${message}`,
          permissions: permissions,
          privateMode: false,
        });
        aiResponse = agentResult?.finalAnswer || "I couldn't process your request using the advanced analysis mode.";
      } catch (error) {
        console.error("Agent mode failed, falling back to simple mode:", error);
        aiResponse = await getSimpleChatResponse(message, context);
      }
    } else {
      // Use simple LLM completion
      aiResponse = await getSimpleChatResponse(message, context);
    }

    const assistantMessage: ChatMessage = {
      role: 'assistant',
      content: aiResponse,
      timestamp: new Date()
    };
    
    setChatMessages(prev => [...prev, assistantMessage]);
  };

  const getSimpleChatResponse = async (message: string, context: string): Promise<string> => {
    const systemPrompt = `You are a helpful assistant analyzing search results from a knowledge base. 
    
The user has provided you with search results and is asking questions about them. Provide clear, concise, and helpful analysis.

Key guidelines:
- Focus on the provided search results
- Be accurate and factual
- Highlight patterns, themes, and connections
- Keep responses conversational but informative
- If results are insufficient for a complete answer, say so

Search Results Context:
${context}`;

    try {
      const response = await aiCompletion({
        prompt: message,
        systemPrompt: systemPrompt,
        instantModel: "gpt-4o-mini",
        responseFormat: "text",
        isButtonToInsert: false,
        selectedUids: null,
        roamContext: null,
        content: "",
        command: "",
        style: "",
        targetUid: "",
        withSuggestions: false,
        target: ""
      });
      
      return response || "I apologize, but I couldn't generate a response at this time.";
    } catch (error) {
      console.error("Simple chat completion failed:", error);
      return "I encountered an error while processing your request. Please try again.";
    }
  };
  
  const toggleChat = () => {
    if (!canUseChat()) {
      // Show upgrade prompt
      alert("Chat functionality requires Balanced or Full access mode. Current mode: Private");
      return;
    }
    setShowChat(!showChat);
  };

  const handleInsertAtDNPEnd = async () => {
    try {
      const selectedResultsList = getSelectedResultsList();
      if (selectedResultsList.length === 0) return;

      // Determine insertion location: targetUid if available, otherwise current DNP
      let insertionParentUid: string;
      if (targetUid) {
        insertionParentUid = targetUid;
      } else {
        // Get today's DNP
        const today = new Date();
        insertionParentUid = `${String(today.getMonth() + 1).padStart(
          2,
          "0"
        )}-${String(today.getDate()).padStart(2, "0")}-${today.getFullYear()}`;
      }

      // First, create the "Selected results:" header block using your custom function
      const headerUid = await createChildBlock(
        insertionParentUid,
        "Selected results:",
        "last"
      );

      if (headerUid) {
        // Create all embed blocks under the header
        for (let idx = 0; idx < selectedResultsList.length; idx++) {
          const result = selectedResultsList[idx];
          if (result && result.uid) {
            const embedText = `{{[[embed-path]]: ((${result.uid}))}}`;
            await createChildBlock(
              headerUid,
              embedText,
              "last"
            );
          }
        }
      }

      handleClose();
    } catch (error) {
      console.error("Failed to insert results:", error);
    }
  };

  const handleInsertInSidebar = () => {
    try {
      const selectedResultsList = getSelectedResultsList();
      if (selectedResultsList.length === 0) return;

      selectedResultsList.forEach((result) => {
        if (result.uid) {
          // Open in sidebar
          (window as any).roamAlphaAPI.ui.rightSidebar.addWindow({
            window: {
              type: "block",
              "block-uid": result.uid,
            },
          });
        }
      });
      // Don't close popup for dropdown actions
    } catch (error) {
      console.error("Failed to insert in sidebar:", error);
    }
  };

  const handleCopyEmbeds = () => {
    const selectedResultsList = getSelectedResultsList();
    if (selectedResultsList.length === 0) return;

    const embedTexts = selectedResultsList
      .filter((result) => result.uid)
      .map((result) => `{{[[embed-path]]: ((${result.uid}))}}`)
      .join("\n");

    navigator.clipboard.writeText(embedTexts);
    handleClose();
  };

  const handleCopyReferences = () => {
    const selectedResultsList = getSelectedResultsList();
    if (selectedResultsList.length === 0) return;

    const references = selectedResultsList
      .filter((result) => result.uid)
      .map((result) => `((${result.uid}))`)
      .join("\n");

    navigator.clipboard.writeText(references);
    // Don't close popup for dropdown actions
  };

  // Simple custom dropdown that definitely works
  const DropdownButton: React.FC<{
    mainText: string;
    mainAction: () => void;
    dropdownOptions: Array<{ text: string; action: () => void }>;
    disabled?: boolean;
    dropdownKey: string;
  }> = ({
    mainText,
    mainAction,
    dropdownOptions,
    disabled = false,
    dropdownKey,
  }) => {
    const isOpen = dropdownStates[dropdownKey] || false;

    const toggleDropdown = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (isClosing) return; // Prevent state updates if closing
      setDropdownStates((prev) => ({
        ...prev,
        [dropdownKey]: !prev[dropdownKey],
      }));
    };

    return (
      <div className="full-results-simple-dropdown">
        <Button
          intent="primary"
          text={mainText}
          onClick={mainAction}
          disabled={disabled}
        />
        <Button
          icon="caret-down"
          intent="primary"
          disabled={disabled}
          onClick={toggleDropdown}
          aria-label="More options"
        />
        {isOpen && (
          <div className="full-results-simple-dropdown-menu">
            {dropdownOptions.map((option, idx) => (
              <button
                key={idx}
                className="full-results-simple-dropdown-item"
                onClick={() => {
                  option.action();
                  if (!isClosing) {
                    setDropdownStates((prev) => ({
                      ...prev,
                      [dropdownKey]: false,
                    }));
                  }
                }}
              >
                {option.text}
              </button>
            ))}
          </div>
        )}
      </div>
    );
  };

  // Fixed: Move hook outside of conditional rendering to avoid React hooks issue
  const renderContent = (result: Result, index: number) => {
    const isPage = result.uid && !result.pageUid;
    
    if (isPage && pageDisplayMode === "metadata") {
      // Simple page metadata view
      return (
        <div className="full-results-page-metadata-view">
          <div className="full-results-page-title">
            📄 {result.pageTitle}
            {result.isDaily && " 📅"}
          </div>
          {result.count && (
            <div className="full-results-page-count">
              Referenced {result.count} times
            </div>
          )}
          {result.pageUid && (
            <div className="full-results-page-uid">
              UID: {result.pageUid}
            </div>
          )}
        </div>
      );
    }
    
    // For blocks or page embeds, use the BlockRenderer component
    return <BlockRenderer result={result} key={`${result.uid}-${index}`} />;
  };

  const renderResultMetadata = (result: Result) => {
    if (!showMetadata) return null;
    
    const isPage = result.uid && !result.pageUid;
    
    return (
      <div className="full-results-metadata">
        <span className={`full-results-type-badge ${isPage ? 'page' : 'block'}`}>
          {isPage ? '📄 Page' : '📝 Block'}
        </span>
        {result.pageTitle && (
          <span className="full-results-page-info">
            {result.pageTitle}
            {result.isDaily && " 📅"}
          </span>
        )}
        {result.modified && (
          <span className="full-results-date-info">
            🕒 {new Date(result.modified).toLocaleDateString()}
          </span>
        )}
        {result.count && (
          <span className="full-results-count-info">
            🔢 {result.count} refs
          </span>
        )}
        {result.uid && (
          <span className="full-results-uid-info">
            🔗 {result.uid.substring(0, 8)}...
          </span>
        )}
      </div>
    );
  };

  return !isOpen ? null : (
    <div
      className="full-results-overlay"
      onClick={(e) => {
        if (e.target === e.currentTarget) {
          handleClose();
        }
      }}
    >
      <div className={`full-results-modal ${showChat ? 'chat-open' : ''}`}>
        <div className="full-results-main-content">
          {/* Header */}
          <div className="full-results-header">
            <h3 className="full-results-title">{title}</h3>
            <button className="full-results-close-button" onClick={handleClose}>
              ×
            </button>
          </div>

          {/* Enhanced Controls */}
          <div className="full-results-controls">
            <div className="full-results-search-filters">
              <InputGroup
                leftIcon="search"
                placeholder="Search within results..."
                value={searchFilter}
                onChange={(e) => setSearchFilter(e.target.value)}
                className="full-results-search-input"
              />
              
              <HTMLSelect
                value={pageFilter}
                onChange={(e) => setPageFilter(e.target.value)}
                className="full-results-page-filter"
              >
                <option value="all">All Pages ({uniquePages.length})</option>
                {uniquePages.map(page => (
                  <option key={page} value={page}>{page}</option>
                ))}
              </HTMLSelect>
            </div>
            
            <div className="full-results-sort-controls">
              <HTMLSelect
                value={sortBy}
                onChange={(e) => setSortBy(e.target.value as any)}
                className="full-results-sort-select"
              >
                <option value="relevance">Sort: Relevance</option>
                <option value="date">Sort: Date</option>
                <option value="page">Sort: Page</option>
                <option value="content">Sort: Content Length</option>
              </HTMLSelect>
              
              <Button
                icon={sortOrder === "desc" ? "sort-desc" : "sort-asc"}
                onClick={() => setSortOrder(sortOrder === "desc" ? "asc" : "desc")}
                title={`Sort ${sortOrder === "desc" ? "Descending" : "Ascending"}`}
              />
              
              <Checkbox
                checked={showMetadata}
                onChange={() => setShowMetadata(!showMetadata)}
                label="Metadata"
                className="full-results-metadata-toggle"
              />
              
              {(hasBlocks || hasPages) && (
                <HTMLSelect
                  value={viewMode}
                  onChange={(e) => setViewMode(e.target.value as any)}
                  className="full-results-view-mode-select"
                >
                  {hasBlocks && hasPages && <option value="mixed">All Types</option>}
                  {hasBlocks && <option value="blocks">Blocks Only</option>}
                  {hasPages && <option value="pages">Pages Only</option>}
                </HTMLSelect>
              )}
              
              {hasPages && viewMode !== "blocks" && (
                <HTMLSelect
                  value={pageDisplayMode}
                  onChange={(e) => setPageDisplayMode(e.target.value as any)}
                  className="full-results-page-display-select"
                >
                  <option value="metadata">Page Info</option>
                  <option value="embed">Page Embed</option>
                </HTMLSelect>
              )}
            </div>
            
            <div className="full-results-pagination-info">
              <span>{filteredAndSortedResults.length} of {results.length} results</span>
              {selectedResults.size > 0 && (
                <span className="full-results-selection-info">
                  ({selectedResults.size} selected)
                </span>
              )}
            </div>
          </div>

          {/* Results */}
          <div className="full-results-list">
            {paginatedResults && paginatedResults.length > 0 ? (
              paginatedResults.map((result, index) => {
                const originalIndex = results.indexOf(result);
                return (
                  <div key={originalIndex} className="full-results-result-item">
                    <input
                      type="checkbox"
                      checked={selectedResults.has(originalIndex)}
                      onChange={() => handleCheckboxChange(index)}
                      className="full-results-checkbox"
                    />
                    <div className="full-results-block-container">
                      {renderResultMetadata(result)}
                      {renderContent(result, index)}
                    </div>
                  </div>
                );
              })
            ) : filteredAndSortedResults.length === 0 ? (
              <div className="full-results-no-results">
                {searchFilter || pageFilter !== "all" ? "No results match current filters" : "No detailed results available"}
              </div>
            ) : (
              <div className="full-results-no-results">No results on current page</div>
            )}
          </div>
          
          {/* Pagination */}
          {totalPages > 1 && (
            <div className="full-results-pagination">
              <div className="full-results-pagination-controls">
                <Button
                  icon="chevron-left"
                  disabled={currentPage === 1}
                  onClick={() => setCurrentPage(Math.max(1, currentPage - 1))}
                  title="Previous page"
                />
                
                <span className="full-results-page-info">
                  Page {currentPage} of {totalPages}
                </span>
                
                <Button
                  icon="chevron-right"
                  disabled={currentPage === totalPages}
                  onClick={() => setCurrentPage(Math.min(totalPages, currentPage + 1))}
                  title="Next page"
                />
              </div>
              
              <div className="full-results-per-page">
                <label>Per page:</label>
                <HTMLSelect
                  value={resultsPerPage}
                  onChange={(e) => {
                    setResultsPerPage(Number(e.target.value));
                    setCurrentPage(1);
                  }}
                >
                  <option value={10}>10</option>
                  <option value={20}>20</option>
                  <option value={50}>50</option>
                  <option value={100}>100</option>
                </HTMLSelect>
              </div>
            </div>
          )}

          {/* Action Bar */}
          <div className="full-results-action-bar">
            <div className="full-results-selection-controls">
              <label className="full-results-select-all-checkbox">
                <input
                  type="checkbox"
                  checked={
                    paginatedResults.length > 0 && 
                    paginatedResults.every(result => selectedResults.has(results.indexOf(result)))
                  }
                  onChange={handleSelectAll}
                  className="full-results-checkbox"
                />
                Page ({paginatedResults.length})
              </label>
              
              <Button
                text={`All Filtered (${filteredAndSortedResults.length})`}
                onClick={handleSelectAllResults}
                small
                minimal
                disabled={filteredAndSortedResults.length === 0}
              />
              
              {selectedResults.size > 0 && (
                <Button
                  text="Clear Selection"
                  onClick={() => setSelectedResults(new Set())}
                  small
                  minimal
                  intent="warning"
                />
              )}
            </div>

            <div className="full-results-buttons-container">
              <DropdownButton
                mainText={
                  targetUid ? "Append to last response" : "Append to today's DNP"
                }
                mainAction={handleInsertAtDNPEnd}
                disabled={selectedResults.size === 0}
                dropdownKey="insert"
                dropdownOptions={[
                  {
                    text: "Open in Sidebar",
                    action: handleInsertInSidebar,
                  },
                ]}
              />

              <DropdownButton
                mainText="Copy Embeds"
                mainAction={handleCopyEmbeds}
                disabled={selectedResults.size === 0}
                dropdownKey="copy"
                dropdownOptions={[
                  {
                    text: "Copy References",
                    action: handleCopyReferences,
                  },
                ]}
              />

              <Button
                text={showChat ? "Hide Chat" : "💬 Chat"}
                onClick={toggleChat}
                intent={showChat ? "none" : "primary"}
                icon={showChat ? "cross" : "chat"}
                disabled={!canUseChat() && !showChat}
                title={!canUseChat() ? "Requires Balanced or Full access mode" : "Chat about selected results"}
              />
              
              <Button text="Close" onClick={handleClose} />
            </div>
          </div>
        </div>
        
        {/* Chat Panel */}
        {showChat && (
          <div className="full-results-chat-panel">
            <div className="full-results-chat-header">
              <h4>💬 Chat Assistant</h4>
              <div className="full-results-chat-info">
                {selectedResults.size > 0 ? (
                  <span>Chatting about {selectedResults.size} selected results</span>
                ) : (
                  <span>Chatting about {paginatedResults.length} visible results</span>
                )}
              </div>
              {privateMode && (
                <div className="full-results-chat-warning">
                  🔒 Limited functionality in Private mode
                </div>
              )}
            </div>
            
            <div className="full-results-chat-messages">
              {chatMessages.length === 0 ? (
                <div className="full-results-chat-welcome">
                  <div className="full-results-chat-assistant-avatar">🤖</div>
                  <div className="full-results-chat-assistant-message">
                    Hi! I can help you analyze and understand your search results. What would you like to know?
                    <div className="full-results-chat-suggestions">
                      <button onClick={() => setChatInput("What are the main themes in these results?")}>Main themes</button>
                      <button onClick={() => setChatInput("Summarize these results for me")}>Summarize</button>
                      <button onClick={() => setChatInput("What connections exist between these items?")}>Find connections</button>
                    </div>
                  </div>
                </div>
              ) : (
                chatMessages.map((message, index) => (
                  <div key={index} className={`full-results-chat-message ${message.role}`}>
                    <div className="full-results-chat-avatar">
                      {message.role === 'user' ? '👤' : '🤖'}
                    </div>
                    <div className="full-results-chat-content">
                      <div className="full-results-chat-text">{message.content}</div>
                      <div className="full-results-chat-timestamp">
                        {message.timestamp.toLocaleTimeString()}
                      </div>
                    </div>
                  </div>
                ))
              )}
              
              {isTyping && (
                <div className="full-results-chat-message assistant">
                  <div className="full-results-chat-avatar">🤖</div>
                  <div className="full-results-chat-content">
                    <div className="full-results-chat-typing">Thinking...</div>
                  </div>
                </div>
              )}
            </div>
            
            <div className="full-results-chat-input-area">
              <div className="full-results-chat-mode-toggle">
                <label>
                  <input
                    type="radio"
                    name="chatMode"
                    value="simple"
                    checked={chatMode === "simple"}
                    onChange={() => setChatMode("simple")}
                  />
                  💬 Simple
                </label>
                <label>
                  <input
                    type="radio"
                    name="chatMode"
                    value="agent"
                    checked={chatMode === "agent"}
                    onChange={() => setChatMode("agent")}
                    disabled={privateMode}
                  />
                  🔍 Deep Analysis
                  {privateMode && <span className="disabled-hint">(Full mode only)</span>}
                </label>
              </div>
              
              <div className="full-results-chat-input-container">
                <InputGroup
                  placeholder="Ask me about your results..."
                  value={chatInput}
                  onChange={(e) => setChatInput(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && handleChatSubmit()}
                  disabled={isTyping}
                  className="full-results-chat-input"
                />
                <Button
                  icon="send-message"
                  onClick={handleChatSubmit}
                  disabled={!chatInput.trim() || isTyping}
                  intent="primary"
                  className="full-results-chat-send"
                />
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default FullResultsPopup;

// Shared utility function for opening last Ask Your Graph results
// Used by both command palette and context menu
export const openLastAskYourGraphResults = () => {
  const lastResults = (window as any).lastAskYourGraphResults;
  if (lastResults && lastResults.length > 0) {
    // Import and use the popup function
    import("./Toaster.js").then(({ openFullResultsPopup }) => {
      if (openFullResultsPopup) {
        const targetUid = (window as any).lastAgentResponseTargetUid || null;
        openFullResultsPopup(lastResults, targetUid);
      }
    }).catch(() => {
      // Fallback for environments where dynamic import doesn't work
      if ((window as any).LiveAI && (window as any).LiveAI.openFullResultsPopup) {
        (window as any).LiveAI.openFullResultsPopup(lastResults);
      } else {
        alert(`Found ${lastResults.length} results, but popup functionality is not available. Results are stored in window.lastAskYourGraphResults`);
      }
    });
  } else {
    console.warn("No Ask Your Graph results available to display");
  }
};

// Function to check if results are available (for conditional command display)
export const hasLastAskYourGraphResults = (): boolean => {
  const results = (window as any).lastAskYourGraphResults;
  return results && Array.isArray(results) && results.length > 0;
};

// Hook for easy usage
export const useFullResultsPopup = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [results, setResults] = useState<Result[]>([]);

  const openPopup = (resultsData: Result[]) => {
    setResults(resultsData);
    setIsOpen(true);
  };

  const closePopup = () => {
    setIsOpen(false);
    setResults([]);
  };

  return {
    isOpen,
    results,
    openPopup,
    closePopup,
    FullResultsPopup: (
      props: Omit<FullResultsPopupProps, "results" | "isOpen" | "onClose">
    ) => <FullResultsPopup {...props} results={results} isOpen={isOpen} />,
  };
};